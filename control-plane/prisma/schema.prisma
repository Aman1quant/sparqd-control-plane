datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  // output   = "app/generated/prisma/client"
}

// ********************************************************************************************************************
//    Core Identity
// ********************************************************************************************************************
model User {
  id        BigInt   @id @default(autoincrement()) // Internal only
  uid       String   @unique @default(uuid()) // Public-facing
  kcSub     String   @unique // Keycloak sub claim
  email     String   @unique
  fullName  String?
  avatarUrl String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  accounts   AccountMember[] // many-to-many through AccountMember
  workspaces Workspace[] // for Workspace.createdBy
  invites    AccountInvite[] @relation("InvitedBy")

  auditLogs            AuditLog[]
  resourcePermissions  ResourcePermission[]
  Resource             Resource[]
  WorkspaceMember      WorkspaceMember[]
  Cluster              Cluster[]
  ClusterConfig        ClusterConfig[]
  ServiceConfig        ServiceConfig[]
  ClusterAutomationJob ClusterAutomationJob[]

  @@map("users")
}

model Account {
  id        BigInt   @id @default(autoincrement())
  uid       String   @unique @default(uuid())
  name      String
  metadata  Json?    @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  kcRealmStatus RealmStatus?

  members    AccountMember[]
  invites    AccountInvite[]
  workspaces Workspace[]

  logs                AuditLog[]
  resourcePermissions ResourcePermission[]
  resource            Resource[]
  accountBilling      AccountBilling?
  storage             AccountStorage[]
  networking          AccountNetwork[]

  @@map("accounts")
}

enum RealmStatus {
  CREATED
  FINALIZED
}

model Role {
  id          Int             @id @default(autoincrement())
  uid         String          @unique @default(uuid())
  name        String          @unique // match with Keycloak role name
  description String?
  members     AccountMember[]

  permissions         RolePermission[]
  resourcePermissions ResourcePermission[]
  WorkspaceMember     WorkspaceMember[]

  @@map("roles")
}

model Permission {
  id          Int              @id @default(autoincrement())
  uid         String           @unique @default(uuid())
  action      String           @unique // e.g. 'project.read', 'project.update'
  description String?
  roles       RolePermission[]

  @@map("permissions")
}

model RolePermission {
  id           Int        @id @default(autoincrement())
  uid          String     @unique @default(uuid())
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade) // TODO: check Cascade or not
  roleId       Int
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade) // TODO: check Cascade or not
  permissionId Int

  @@unique([roleId, permissionId])
  @@map("role_permissions")
}

// ********************************************************************************************************************
//    Account Configuration
// ********************************************************************************************************************

enum Provider {
  AWS
}

model AccountStorage {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade) // TODO: check Cascade or not
  accountId BigInt

  storageName  String
  providerName Provider

  // AWS provider
  awsRootBucketName String?

  // Other providers TODO

  createdAt DateTime @default(now())

  // Relations
  Workspace Workspace[]

  @@map("account_storages")
}

model AccountNetwork {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade) // TODO: check Cascade or not
  accountId BigInt

  networkName  String
  providerName Provider

  // AWS provider
  awsVpcId            String?
  awsSubnetIds        String[]
  awsSecurityGroupIds String[]

  // Other providers TODO

  createdAt DateTime @default(now())

  // Relations
  Workspace Workspace[]

  @@map("account_networks")
}

// ********************************************************************************************************************
//    Account Membership
// ********************************************************************************************************************
model AccountInvite {
  id          BigInt    @id @default(autoincrement())
  uid         String    @unique @default(uuid())
  account     Account   @relation(fields: [accountId], references: [id], onDelete: Cascade) // TODO: check Cascade or not
  accountId   BigInt
  email       String
  invitedBy   User?     @relation("InvitedBy", fields: [invitedById], references: [id])
  invitedById BigInt?
  role        String    @default("member")
  token       String    @unique
  acceptedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([accountId, email])
  @@map("account_invites")
}

model AccountMember {
  id        BigInt   @id @default(autoincrement())
  uid       String   @unique @default(uuid())
  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade) // TODO: check Cascade or not
  accountId BigInt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade) // TODO: check Cascade or not
  userId    BigInt
  role      Role     @relation(fields: [roleId], references: [id])
  roleId    Int // Foreign key to Role table
  joinedAt  DateTime @default(now())

  @@unique([accountId, userId])
  @@map("account_members")
}

// ********************************************************************************************************************
//    Resource RBAC/ABAC
// ********************************************************************************************************************
model Resource {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId BigInt

  type        String // 'project', 'dataset', etc.
  targetId    BigInt // ID of the actual resource (e.g. project.id)
  name        String? // Optional — override or fallback name
  description String?
  metadata    Json?   @default("{}")

  createdBy   User?   @relation(fields: [createdById], references: [id])
  createdById BigInt?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  permissions ResourcePermission[]

  @@unique([type, targetId])
  @@index([accountId, type])
  @@map("resources")
}

model ResourcePermission {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId BigInt

  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId BigInt

  role   Role @relation(fields: [roleId], references: [id])
  roleId Int

  resourceType String // e.g. 'project', 'data'
  resourceId   BigInt? // optional direct link
  resourceName String? // e.g. 's3://bucket/data/*'

  actions   String[] // ← updated to support multiple actions like ['read', 'write']
  condition Json?    @default("{}") // optional ABAC conditions like time, IP, S3 bucket wildcard

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Resource Resource? @relation(fields: [resourceId], references: [id])

  @@index([userId, resourceType, resourceId])
  @@index([userId, resourceType, resourceName])
  @@map("resource_permissions")
}

// ********************************************************************************************************************
//    Workspace
// ********************************************************************************************************************
model Workspace {
  id          BigInt  @id @default(autoincrement())
  uid         String  @unique @default(uuid())
  account     Account @relation(fields: [accountId], references: [id], onDelete: Cascade) // TODO: check Cascade or not
  accountId   BigInt
  name        String
  description String?
  metadata    Json?   @default("{}")

  // Workspace Configuration
  storage   AccountStorage @relation(fields: [storageId], references: [id], onDelete: Restrict)
  storageId BigInt  @default(0)

  network   AccountNetwork @relation(fields: [networkId], references: [id], onDelete: Restrict)
  networkId BigInt  @default(0)

  members WorkspaceMember[]

  createdBy   User?    @relation(fields: [createdById], references: [id])
  createdById BigInt?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  Cluster Cluster[]

  @@index([accountId, name])
  @@map("workspaces")
}

model WorkspaceMember {
  id          BigInt    @id @default(autoincrement())
  uid         String    @unique @default(uuid())
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  workspaceId BigInt
  user        User      @relation(fields: [userId], references: [id])
  userId      BigInt
  role        Role      @relation(fields: [roleId], references: [id])
  roleId      Int
  joinedAt    DateTime  @default(now())

  @@unique([workspaceId, userId])
  @@map("workspace_members")
}

// ********************************************************************************************************************
//    Cluster, compute
// ********************************************************************************************************************
model Cluster {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  workspaceId BigInt

  name        String
  description String?

  tshirtSize   String
  status       ClusterStatus @default(CREATING)
  statusReason String?
  metadata     Json?         @default("{}")

  // Relation to ClusterConfig
  currentConfig   ClusterConfig?  @relation("CurrentClusterConfig", fields: [currentConfigId], references: [id])
  currentConfigId BigInt?         @unique // MUST be unique for 1-1
  configs         ClusterConfig[] @relation("ClusterToConfigs")

  // Relation to ClusterEvent
  latestEvent   ClusterEvent?  @relation("LatestClusterEvent", fields: [latestEventId], references: [id])
  latestEventId BigInt?        @unique
  events        ClusterEvent[] @relation("ClusterToEvents")

  services ServiceInstance[]
  jobs     ClusterAutomationJob[]

  createdBy   User?    @relation(fields: [createdById], references: [id])
  createdById BigInt?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // billing  BillingRecord[] // 🕒 deferred
  // logs     MonitoringLogRef[] // 🕒 deferred
  Usage         Usage[]
  BillingRecord BillingRecord[]

  @@map("clusters")
}

enum ClusterStatus {
  PENDING
  CREATING
  CREATE_FAILED
  RUNNING
  UPDATING
  UPDATE_FAILED
  STOPPING
  STOPPED
  STOP_FAILED
  DELETING
  DELETE_FAILED
  DELETED
}

model ClusterConfig {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  cluster           Cluster  @relation("ClusterToConfigs", fields: [clusterId], references: [id])
  clusterId         BigInt
  currentForCluster Cluster? @relation("CurrentClusterConfig")

  version    Int
  tshirtSize String
  services   Json
  rawSpec    Json

  createdBy   User?    @relation(fields: [createdById], references: [id])
  createdById BigInt?
  createdAt   DateTime @default(now())

  @@map("cluster_configs")
}

model ClusterEvent {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  cluster          Cluster  @relation("ClusterToEvents", fields: [clusterId], references: [id])
  clusterId        BigInt
  latestForCluster Cluster? @relation("LatestClusterEvent")

  before Json
  after  Json

  createdAt DateTime @default(now())

  @@map("cluster_events")
}

enum AutomationJobStatus {
  PENDING
  RUNNING
  RETRYING
  FAILED
  COMPLETED
  CANCELLED
  TIMEOUT
}

model ClusterAutomationJob {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  cluster   Cluster @relation(fields: [clusterId], references: [id])
  clusterId BigInt

  type    String // e.g. 'CREATE', 'UPDATE_CONFIG', 'DESTROY'
  status  AutomationJobStatus @default(PENDING)
  logsUrl String? // external CI/CD or GitOps job link
  output  Json? // optional result

  attempts    Int       @default(0) // how many times it retried
  lastTriedAt DateTime? // last execution time
  nextRetryAt DateTime? // optional: for exponential backoff or queue scheduler
  failReason  String? // optional: for logging error

  createdBy   User?    @relation(fields: [createdById], references: [id])
  createdById BigInt?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("cluster_automation_jobs")
}

// ********************************************************************************************************************
//    Pricing?
// Example
// | itemType | itemName   | unit       | unitPrice | startsAt         | endsAt           |
// | -------- | ---------- | ---------- | --------- | ---------------- | ---------------- |
// | cluster  | compute\:S | vCPU/hour  | 0.02      | 2024-01-01 00:00 | 2024-06-01 00:00 |
// | cluster  | compute\:S | vCPU/hour  | 0.025     | 2024-06-01 00:00 | *(null)*         |
// | service  | spark      | unit/month | 300000    | 2024-01-01 00:00 | *(null)*         |
// | storage  | disk\:ssd  | GB/month   | 1200      | 2024-01-01 00:00 | *(null)*         |

// ********************************************************************************************************************
model Pricing {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  // What is being priced
  itemType String // e.g., 'service', 'cluster', 'storage', 'egress'
  itemName String // e.g., 'spark', 's3', 'compute:M', 'disk:SSD'
  unit     String // e.g., 'vCPU/hour', 'GB/day', 'unit/month'

  // Pricing details
  unitPrice Float // in default currency (e.g. IDR)
  currency  String @default("IDR")

  startsAt DateTime // When this price becomes active
  endsAt   DateTime? // Optional — open-ended if latest

  metadata Json? @default("{}") // Optional: region, notes, tier flags

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("pricings")
}

// ********************************************************************************************************************
//    Services
// ********************************************************************************************************************
model Service {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  name        String  @unique // e.g. 'spark', 'trino'
  displayName String? // Optional: 'Apache Spark'
  description String?
  isActive    Boolean @default(true) // mark available or deprecated
  isFreeTier  Boolean @default(false) // mark for free plan
  metadata    Json?   @default("{}") // for icon, category, etc.

  versions ServiceVersion[] // optional for Helm/Git versioning

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  ServiceInstance ServiceInstance[]

  @@map("services")
}

model ServiceVersion {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  service   Service @relation(fields: [serviceId], references: [id])
  serviceId BigInt

  version     String // e.g. 'v1.4.0', or chart version
  releaseDate DateTime
  changelog   String?
  isActive    Boolean  @default(true) // mark available or deprecated
  isDefault   Boolean  @default(false)

  metadata Json? @default("{}") // git commit, Helm repo, image hash, etc.

  createdAt       DateTime          @default(now())
  ServiceInstance ServiceInstance[]

  @@map("service_versions")
}

model ServiceInstance {
  id  BigInt @id @default(autoincrement())
  uid String @unique @default(uuid())

  cluster   Cluster @relation(fields: [clusterId], references: [id])
  clusterId BigInt

  service   Service @relation(fields: [serviceId], references: [id])
  serviceId BigInt

  version   ServiceVersion? @relation(fields: [versionId], references: [id])
  versionId BigInt?

  config   ServiceConfig? @relation(fields: [configId], references: [id])
  configId BigInt?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("service_instances")
}

model ServiceConfig {
  id BigInt @id @default(autoincrement())

  uid      String @unique @default(uuid())
  cpu      Float?
  memory   Float?
  disk     Float?
  metadata Json?  @default("{}")

  createdBy       User?             @relation(fields: [createdById], references: [id])
  createdById     BigInt?
  createdAt       DateTime          @default(now())
  ServiceInstance ServiceInstance[]

  @@map("service_configs")
}

// ********************************************************************************************************************
//    Usage & Billing
// ********************************************************************************************************************
model AccountBilling {
  id        BigInt  @id @default(autoincrement())
  uid       String  @unique @default(uuid())
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId BigInt  @unique // 1:1 with Account

  billingEmail   String // Email to send invoice
  billingName    String? // Optional legal name
  billingAddress Json? // Optional address
  taxId          String? // For VAT, PPN, etc.
  currency       String  @default("USD")

  plan          String @default("free") // 'free', 'starter', 'pro', 'enterprise'
  paymentMethod Json? // Could store Stripe/FastSpring/etc. reference
  billingCycle  String @default("monthly") // monthly, yearly, etc.

  trialEndsAt       DateTime?
  subscriptionStart DateTime?
  subscriptionEnd   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // invoices   Invoice[] // optional for roadmap

  @@map("account_billings")
}

// raw metered usage from clusters (optional if storing external)
model Usage {
  id        BigInt  @id @default(autoincrement())
  uid       String  @unique @default(uuid())
  cluster   Cluster @relation(fields: [clusterId], references: [id])
  clusterId BigInt
  service   String // 'spark', 'trino', etc.

  timestamp DateTime // UTC bucket timestamp
  cpu       Float? // in cores
  memory    Float? // in GB
  disk      Float? // in GB
  duration  Float? // in seconds, optional
  unitPrice Float? // snapshot of pricing
  metadata  Json? // for labels or tags

  createdAt DateTime @default(now())

  @@map("usages")
}

// aggregated per resource, for invoicing
model BillingRecord {
  id        BigInt  @id @default(autoincrement())
  uid       String  @unique @default(uuid())
  cluster   Cluster @relation(fields: [clusterId], references: [id])
  clusterId BigInt

  service    String
  periodFrom DateTime
  periodTo   DateTime
  usageCpu   Float?
  usageMem   Float?
  usageDisk  Float?
  cost       Float
  currency   String   @default("IDR")

  // invoice     Invoice? @relation(fields: [invoiceId], references: [id])
  // invoiceId   BigInt?

  generatedAt DateTime @default(now())

  @@map("billing_records")
}

// ********************************************************************************************************************
//    Audit & governance
// ********************************************************************************************************************
model AuditLog {
  id           BigInt   @id @default(autoincrement())
  uid          String   @unique @default(uuid())
  account      Account  @relation(fields: [accountId], references: [id], onDelete: SetNull)
  accountId    BigInt
  accountName  String? // ← snapshot at log time   
  user         User?    @relation(fields: [userId], references: [id])
  userId       BigInt?
  userEmail    String? // ← snapshot at log time
  action       String
  resourceType String?
  resourceId   BigInt?
  metadata     Json?    @default("{}")
  createdAt    DateTime @default(now())

  @@map("audit_logs")
}
